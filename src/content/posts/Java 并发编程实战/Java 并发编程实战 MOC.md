---
title: Java 并发编程实战 MOC
pubDate: 2024-01-01
categories: ['Java']
description: Java 并发编程实战 MOC
---

## Java 并发编程实战 MOC 

 - [[01、可见性、原子性和有序性问题：并发编程Bug的源头]]
 - [[02、Java内存模型：看Java如何解决可见性和有序性问题]]
 - [[03、互斥锁（上）：解决原子性问题]]
 - [[04、互斥锁（下）：如何用一把锁保护多个资源？]]
 - [[05、一不小心就死锁了，怎么办？]]
 - [[06、用“等待-通知”机制优化循环等待]]
 - [[07、安全性、活跃性以及性能问题]]
 - [[08、管程：并发编程的万能钥匙]]
 - [[09、Java线程（上）：Java线程的生命周期]]
 - [[10、Java线程（中）：创建多少线程才是合适的？]]
 - [[11、Java线程（下）：为什么局部变量是线程安全的？]]
 - [[12、如何用面向对象思想写好并发程序？]]
 - [[13、理论基础模块热点问题答疑]]
 - [[14、Lock和Condition（上）：隐藏在并发包中的管程]]
 - [[15、Lock和Condition（下）：Dubbo如何用管程实现异步转同步？]]
 - [[16、Semaphore：如何快速实现一个限流器？]]
 - [[17、ReadWriteLock：如何快速实现一个完备的缓存？]]
 - [[18、StampedLock：有没有比读写锁更快的锁？]]
 - [[19、CountDownLatch和CyclicBarrier：如何让多线程步调一致？]]
 - [[20、并发容器：都有哪些“坑”需要我们填？]]
 - [[21、原子类：无锁工具类的典范]]
 - [[22、Executor与线程池：如何创建正确的线程池？]]
 - [[23、Future：如何用多线程实现最优的“烧水泡茶”程序？]]
 - [[24、CompletableFuture：异步编程没那么难]]
 - [[25、CompletionService：如何批量执行异步任务？]]
 - [[27、并发工具类模块热点问题答疑]]
 - [[28、Immutability模式：如何利用不变性解决并发问题？]]
 - [[29、Copy-on-Write模式：不是延时策略的COW]]
 - [[30、线程本地存储模式：没有共享，就没有伤害]]
 - [[31、Guarded Suspension模式：等待唤醒机制的规范实现]]
 - [[32、Balking模式：再谈线程安全的单例模式]]
 - [[33、Thread-Per-Message模式：最简单实用的分工方法]]
 - [[34、Worker Thread模式：如何避免重复创建线程？]]
 - [[35、两阶段终止模式：如何优雅地终止线程？]]
 - [[36、生产者-消费者模式：用流水线思想提高效率]]
 - [[37、设计模式模块热点问题答疑]]
 - [[39、案例分析（二）：高性能网络应用框架Netty]]
 - [[40、案例分析（三）：高性能队列Disruptor]]
 - [[41、案例分析（四）：高性能数据库连接池HiKariCP]]
 - [[学习攻略、如何才能学好并发编程？]]